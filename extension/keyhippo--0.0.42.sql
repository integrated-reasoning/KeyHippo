/*
 * Copyright (c) 2024 Integrated Reasoning, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ██╗  ██╗███████╗██╗   ██╗██╗  ██╗██╗██████╗ ██████╗  ██████╗
 * ██║ ██╔╝██╔════╝╚██╗ ██╔╝██║  ██║██║██╔══██╗██╔══██╗██╔═══██╗
 * █████╔╝ █████╗   ╚████╔╝ ███████║██║██████╔╝██████╔╝██║   ██║
 * ██╔═██╗ ██╔══╝    ╚██╔╝  ██╔══██║██║██╔═══╝ ██╔═══╝ ██║   ██║
 * ██║  ██╗███████╗   ██║   ██║  ██║██║██║     ██║     ╚██████╔╝
 * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝╚═╝     ╚═╝      ╚═════╝
 */
-- Create KeyHippo schema
CREATE SCHEMA IF NOT EXISTS keyhippo;

-- Create KeyHippo internal schema
CREATE SCHEMA IF NOT EXISTS keyhippo_internal;

-- Create RBAC schema
CREATE SCHEMA IF NOT EXISTS keyhippo_rbac;

-- Create Impersonation schema
CREATE SCHEMA IF NOT EXISTS keyhippo_impersonation;

-- Ensure required extensions are installed
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE EXTENSION IF NOT EXISTS pg_net;

-- Create custom types
CREATE TYPE keyhippo.app_permission AS ENUM (
    'manage_groups',
    'manage_roles',
    'manage_permissions',
    'manage_scopes',
    'manage_user_attributes',
    'manage_api_keys'
);

CREATE TYPE keyhippo.app_role AS ENUM (
    'admin',
    'user'
);

-- Create config table
CREATE TABLE keyhippo_internal.config (
    key text PRIMARY KEY,
    value text NOT NULL,
    description text
);

-- Create RBAC tables
CREATE TABLE keyhippo_rbac.groups (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid (),
    name text UNIQUE NOT NULL,
    description text
);

CREATE TABLE keyhippo_rbac.roles (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid (),
    name text NOT NULL,
    description text,
    group_id uuid NOT NULL REFERENCES keyhippo_rbac.groups (id) ON DELETE CASCADE,
    role_type keyhippo.app_role NOT NULL DEFAULT 'user',
    UNIQUE (name, group_id)
);

CREATE TABLE keyhippo_rbac.permissions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid (),
    name keyhippo.app_permission UNIQUE NOT NULL,
    description text
);

CREATE TABLE keyhippo_rbac.role_permissions (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_id uuid NOT NULL REFERENCES keyhippo_rbac.roles (id) ON DELETE CASCADE,
    permission_id uuid NOT NULL REFERENCES keyhippo_rbac.permissions (id) ON DELETE CASCADE,
    UNIQUE (role_id, permission_id)
);

CREATE TABLE keyhippo_rbac.user_group_roles (
    user_id uuid NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    group_id uuid NOT NULL REFERENCES keyhippo_rbac.groups (id) ON DELETE CASCADE,
    role_id uuid NOT NULL REFERENCES keyhippo_rbac.roles (id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, group_id, role_id)
);

-- Create KeyHippo tables
CREATE TABLE keyhippo.scopes (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid (),
    name text NOT NULL UNIQUE,
    description text
);

CREATE TABLE keyhippo.scope_permissions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid (),
    scope_id uuid NOT NULL REFERENCES keyhippo.scopes (id),
    permission_id uuid NOT NULL REFERENCES keyhippo_rbac.permissions (id),
    UNIQUE (scope_id, permission_id)
);

CREATE TABLE keyhippo.api_key_metadata (
    id uuid PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    scope_id uuid REFERENCES keyhippo.scopes (id),
    description text,
    prefix text NOT NULL UNIQUE,
    created_at timestamptz NOT NULL DEFAULT now(),
    last_used_at timestamptz,
    expires_at timestamptz NOT NULL DEFAULT (now() + interval '100 years'),
    is_revoked boolean NOT NULL DEFAULT FALSE
);

CREATE TABLE keyhippo.api_key_secrets (
    key_metadata_id uuid PRIMARY KEY REFERENCES keyhippo.api_key_metadata (id) ON DELETE CASCADE,
    key_hash text NOT NULL
);

CREATE TABLE keyhippo.audit_log (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid (),
    timestamp timestamptz NOT NULL DEFAULT now(),
    action text NOT NULL,
    table_name text,
    data jsonb,
    user_id uuid,
    function_name text
);

CREATE OR REPLACE FUNCTION keyhippo.log_table_change ()
    RETURNS TRIGGER
    AS $$
DECLARE
    v_data jsonb;
    v_user_id uuid;
BEGIN
    -- Get the current user ID
    SELECT
        user_id INTO v_user_id
    FROM
        keyhippo.current_user_context ();
    -- Prepare the data JSON
    IF (TG_OP = 'DELETE') THEN
        v_data := jsonb_build_object('old_data', to_jsonb (OLD));
    ELSIF (TG_OP = 'UPDATE') THEN
        v_data := jsonb_build_object('old_data', to_jsonb (OLD), 'new_data', to_jsonb (NEW));
    ELSIF (TG_OP = 'INSERT') THEN
        v_data := jsonb_build_object('new_data', to_jsonb (NEW));
    END IF;
    -- Insert into audit_log
    INSERT INTO keyhippo.audit_log (action, table_name, data, user_id)
        VALUES (TG_OP, TG_TABLE_NAME, v_data, v_user_id);
    RETURN NEW;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER;

CREATE TRIGGER keyhippo_audit_rbac_groups
    AFTER INSERT OR UPDATE OR DELETE ON keyhippo_rbac.groups
    FOR EACH ROW
    EXECUTE FUNCTION keyhippo.log_table_change ();

CREATE TRIGGER keyhippo_audit_rbac_roles
    AFTER INSERT OR UPDATE OR DELETE ON keyhippo_rbac.roles
    FOR EACH ROW
    EXECUTE FUNCTION keyhippo.log_table_change ();

CREATE TRIGGER keyhippo_audit_rbac_permissions
    AFTER INSERT OR UPDATE OR DELETE ON keyhippo_rbac.permissions
    FOR EACH ROW
    EXECUTE FUNCTION keyhippo.log_table_change ();

CREATE TRIGGER keyhippo_audit_rbac_role_permissions
    AFTER INSERT OR UPDATE OR DELETE ON keyhippo_rbac.role_permissions
    FOR EACH ROW
    EXECUTE FUNCTION keyhippo.log_table_change ();

CREATE TRIGGER keyhippo_audit_rbac_user_group_roles
    AFTER INSERT OR UPDATE OR DELETE ON keyhippo_rbac.user_group_roles
    FOR EACH ROW
    EXECUTE FUNCTION keyhippo.log_table_change ();

CREATE TRIGGER keyhippo_audit_scopes
    AFTER INSERT OR UPDATE OR DELETE ON keyhippo.scopes
    FOR EACH ROW
    EXECUTE FUNCTION keyhippo.log_table_change ();

CREATE TRIGGER keyhippo_audit_scope_permissions
    AFTER INSERT OR UPDATE OR DELETE ON keyhippo.scope_permissions
    FOR EACH ROW
    EXECUTE FUNCTION keyhippo.log_table_change ();

CREATE TRIGGER keyhippo_audit_api_key_metadata
    AFTER INSERT OR UPDATE OR DELETE ON keyhippo.api_key_metadata
    FOR EACH ROW
    EXECUTE FUNCTION keyhippo.log_table_change ();

CREATE OR REPLACE FUNCTION keyhippo_internal.notify_audit_change ()
    RETURNS TRIGGER
    AS $$
DECLARE
    v_payload jsonb;
    v_request_id bigint;
    v_endpoint text;
    v_installation_uuid uuid;
    v_enable_http_logging boolean;
BEGIN
    SELECT
        value::boolean INTO v_enable_http_logging
    FROM
        keyhippo_internal.config
    WHERE
        key = 'enable_http_logging';
    -- Only proceed if HTTP logging is enabled
    IF v_enable_http_logging THEN
        -- Get the endpoint and configuration from the config table
        SELECT
            value INTO v_endpoint
        FROM
            keyhippo_internal.config
        WHERE
            key = 'audit_log_endpoint';
        SELECT
            value::uuid INTO v_installation_uuid
        FROM
            keyhippo_internal.config
        WHERE
            key = 'installation_uuid';
        -- Prepare the payload
        v_payload = jsonb_build_object('id', NEW.id, 'timestamp', NEW.timestamp, 'action', NEW.action, 'table_name', NEW.table_name, 'user_id', NEW.user_id, 'function_name', NEW.function_name, 'data', NEW.data, 'installation_uuid', v_installation_uuid);
        -- Make the HTTP request
        SELECT
            net.http_post (v_endpoint, v_payload, headers := '{"Content-Type": "application/json"}'::jsonb) INTO v_request_id;
        -- Log the request_id (optional, for debugging)
        RAISE NOTICE 'HTTP Request ID: %', v_request_id;
    END IF;
    RETURN NEW;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER;

-- Function to enable the audit_log_notify trigger
CREATE OR REPLACE FUNCTION keyhippo_internal.enable_audit_log_notify ()
    RETURNS VOID
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
BEGIN
    -- Create the trigger
    CREATE OR REPLACE TRIGGER keyhippo_audit_log_notify
        AFTER INSERT ON keyhippo.audit_log
        FOR EACH ROW
        EXECUTE FUNCTION keyhippo_internal.notify_audit_change ( );
END;
$$;

-- Function to disable the audit_log_notify trigger
CREATE OR REPLACE FUNCTION keyhippo_internal.disable_audit_log_notify ()
    RETURNS VOID
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
BEGIN
    DROP TRIGGER IF EXISTS keyhippo_audit_log_notify ON keyhippo.audit_log;
END;
$$;

CREATE OR REPLACE FUNCTION keyhippo.is_authorized (target_resource regclass, required_permission text)
    RETURNS boolean
    AS $$
DECLARE
    v_user_id uuid;
    v_user_id_text text;
    v_is_authorized boolean;
BEGIN
    -- Get the current user ID from the JWT claim
    v_user_id_text := current_setting('request.jwt.claim.sub', TRUE);
    -- If no user ID is found or it's an empty string, return false
    IF v_user_id_text IS NULL OR v_user_id_text = '' THEN
        RETURN FALSE;
    END IF;
    -- Try to cast the user ID to UUID
    BEGIN
        v_user_id := v_user_id_text::uuid;
    EXCEPTION
        WHEN invalid_text_representation THEN
            -- If casting fails, return false
            RETURN FALSE;
    END;
    -- Check if the user has the required permission
    SELECT
        EXISTS (
            SELECT
                1
            FROM
                keyhippo_rbac.user_group_roles ugr
                JOIN keyhippo_rbac.role_permissions rp ON ugr.role_id = rp.role_id
                JOIN keyhippo_rbac.permissions p ON rp.permission_id = p.id
            WHERE
                ugr.user_id = v_user_id
                AND p.name = required_permission) INTO v_is_authorized;
    RETURN v_is_authorized;
END;

$$
LANGUAGE plpgsql
SECURITY DEFINER;

-- Create Impersonation table
CREATE TABLE IF NOT EXISTS keyhippo_impersonation.impersonation_state (
    impersonated_user_id uuid PRIMARY KEY,
    original_role name NOT NULL,
    impersonation_time timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_api_key_metadata_user_id ON keyhippo.api_key_metadata (user_id);

CREATE INDEX idx_user_group_roles_user_id ON keyhippo_rbac.user_group_roles (user_id);

CREATE INDEX idx_roles_name ON keyhippo_rbac.roles (name);

-- Authorization function
CREATE OR REPLACE FUNCTION keyhippo.authorize (requested_permission keyhippo.app_permission)
    RETURNS boolean
    AS $$
DECLARE
    bind_permissions int;
    user_role keyhippo.app_role;
BEGIN
    -- Fetch user role from the JWT
    SELECT
        (current_setting('request.jwt.claims', TRUE)::jsonb ->> 'user_role')::keyhippo.app_role INTO user_role;
    SELECT
        COUNT(*) INTO bind_permissions
    FROM
        keyhippo_rbac.role_permissions rp
        JOIN keyhippo_rbac.roles r ON rp.role_id = r.id
        JOIN keyhippo_rbac.permissions p ON rp.permission_id = p.id
    WHERE
        p.name = requested_permission
        AND r.role_type = user_role;
    RETURN bind_permissions > 0;
END;
$$
LANGUAGE plpgsql
STABLE
SECURITY DEFINER SET search_path = '';

-- Function to create an API key
CREATE OR REPLACE FUNCTION keyhippo.create_api_key (key_description text, scope_name text DEFAULT NULL)
    RETURNS TABLE (
        api_key text,
        api_key_id uuid)
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
DECLARE
    random_bytes bytea;
    new_api_key text;
    new_api_key_id uuid;
    authenticated_user_id uuid;
    prefix text;
    scope_id uuid;
BEGIN
    -- Get the authenticated user ID
    authenticated_user_id := auth.uid ();
    -- Check if the user is authenticated
    IF authenticated_user_id IS NULL THEN
        RAISE EXCEPTION 'Unauthorized: User not authenticated';
    END IF;
    -- Validate key description
    IF LENGTH(key_description) > 255 OR key_description !~ '^[a-zA-Z0-9_ \-]*$' THEN
        RAISE EXCEPTION '[KeyHippo] Invalid key description';
    END IF;
    -- Handle scope
    IF scope_name IS NULL THEN
        scope_id := NULL;
    ELSE
        SELECT
            id INTO scope_id
        FROM
            keyhippo.scopes
        WHERE
            name = scope_name;
        IF scope_id IS NULL THEN
            RAISE EXCEPTION '[KeyHippo] Invalid scope';
        END IF;
    END IF;
    -- Generate API key
    random_bytes := extensions.gen_random_bytes(64);
    new_api_key := encode(extensions.digest(random_bytes, 'sha512'), 'hex');
    new_api_key_id := gen_random_uuid ();
    prefix := encode(extensions.gen_random_bytes(24), 'base64');
    -- Insert metadata
    INSERT INTO keyhippo.api_key_metadata (id, user_id, description, prefix, scope_id)
        VALUES (new_api_key_id, authenticated_user_id, key_description, prefix, scope_id);
    -- Store hash
    INSERT INTO keyhippo.api_key_secrets (key_metadata_id, key_hash)
        VALUES (new_api_key_id, encode(extensions.digest(new_api_key, 'sha512'), 'hex'));
    RETURN QUERY
    SELECT
        prefix || new_api_key,
        new_api_key_id;
END;
$$;

-- Function to verify an API key
CREATE OR REPLACE FUNCTION keyhippo.verify_api_key (api_key text)
    RETURNS TABLE (
        user_id uuid,
        scope_id uuid,
        permissions text[])
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
DECLARE
    metadata_id uuid;
    prefix_part text;
    key_part text;
    stored_key_hash text;
    computed_hash text;
    v_user_id uuid;
    v_scope_id uuid;
BEGIN
    -- Split and verify API key
    IF LENGTH(api_key) <= 128 THEN
        RAISE EXCEPTION 'Invalid API key format';
    END IF;
    prefix_part :=
    LEFT (api_key,
        LENGTH(api_key) - 128);
    key_part :=
    RIGHT (api_key,
        128);
    -- Retrieve metadata
    SELECT
        m.id,
        m.user_id,
        m.scope_id INTO metadata_id,
        v_user_id,
        v_scope_id
    FROM
        keyhippo.api_key_metadata m
    WHERE
        m.prefix = prefix_part
        AND NOT m.is_revoked
        AND m.expires_at > NOW();
    IF metadata_id IS NULL THEN
        RETURN;
    END IF;
    -- Verify key hash
    SELECT
        key_hash INTO stored_key_hash
    FROM
        keyhippo.api_key_secrets
    WHERE
        key_metadata_id = metadata_id;
    computed_hash := encode(extensions.digest(key_part, 'sha512'), 'hex');
    IF computed_hash = stored_key_hash THEN
        -- Update last_used_at if necessary
        UPDATE
            keyhippo.api_key_metadata
        SET
            last_used_at = NOW()
        WHERE
            id = metadata_id
            AND (last_used_at IS NULL
                OR last_used_at < NOW() - INTERVAL '1 minute');
        -- Return user_id, scope_id, and permissions
        RETURN QUERY
        SELECT
            v_user_id,
            v_scope_id,
            ARRAY_AGG(DISTINCT p.name::text)
        FROM
            keyhippo.api_key_metadata akm
        LEFT JOIN keyhippo.scope_permissions sp ON akm.scope_id = sp.scope_id
        LEFT JOIN keyhippo_rbac.permissions p ON sp.permission_id = p.id
    WHERE
        akm.id = metadata_id
    GROUP BY
        v_user_id,
        v_scope_id;
    END IF;
END;
$$;

-- Function to get user_id and scope from API key or JWT
CREATE OR REPLACE FUNCTION keyhippo.current_user_context ()
    RETURNS TABLE (
        user_id uuid,
        scope_id uuid,
        permissions text[])
    LANGUAGE plpgsql
    SECURITY INVOKER
    AS $$
DECLARE
    api_key text;
    v_user_id uuid;
    v_scope_id uuid;
    v_permissions text[];
BEGIN
    api_key := current_setting('request.headers', TRUE)::json ->> 'x-api-key';
    IF api_key IS NOT NULL THEN
        SELECT
            vak.user_id,
            vak.scope_id,
            vak.permissions INTO v_user_id,
            v_scope_id,
            v_permissions
        FROM
            keyhippo.verify_api_key (api_key) vak;
        IF v_user_id IS NOT NULL THEN
            RETURN QUERY
            SELECT
                v_user_id,
                v_scope_id,
                v_permissions;
            RETURN;
        END IF;
    END IF;
    v_user_id := auth.uid ();
    IF v_user_id IS NULL THEN
        RETURN;
    END IF;
    SELECT
        ARRAY_AGG(DISTINCT p.name::text) INTO v_permissions
    FROM
        keyhippo_rbac.user_group_roles ugr
        JOIN keyhippo_rbac.role_permissions rp ON ugr.role_id = rp.role_id
        JOIN keyhippo_rbac.permissions p ON rp.permission_id = p.id
    WHERE
        ugr.user_id = v_user_id;
    RETURN QUERY
    SELECT
        v_user_id,
        NULL::uuid,
        COALESCE(v_permissions, ARRAY[]::text[]);
END;
$$;

-- Function to revoke an API key
CREATE OR REPLACE FUNCTION keyhippo.revoke_api_key (api_key_id uuid)
    RETURNS boolean
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
DECLARE
    success boolean;
    c_user_id uuid;
    c_scope_id uuid;
BEGIN
    SELECT
        user_id,
        scope_id INTO c_user_id,
        c_scope_id
    FROM
        keyhippo.current_user_context ();
    IF c_user_id IS NULL THEN
        RAISE EXCEPTION 'Unauthorized';
    END IF;
    -- Update to set is_revoked only if it's not already revoked
    -- and the user has permission (either they created the key or it's within their scope)
    UPDATE
        keyhippo.api_key_metadata
    SET
        is_revoked = TRUE
    WHERE
        id = api_key_id
        AND ((user_id = c_user_id
                AND scope_id IS NULL)
            OR (scope_id = c_scope_id))
        AND is_revoked = FALSE
    RETURNING
        TRUE INTO success;
    IF success THEN
        -- Delete the secret hash to ensure it's no longer usable
        DELETE FROM keyhippo.api_key_secrets
        WHERE key_metadata_id = api_key_id;
    END IF;
    RETURN COALESCE(success, FALSE);
END;
$$;

-- Function to rotate an API key
CREATE OR REPLACE FUNCTION keyhippo.rotate_api_key (old_api_key_id uuid)
    RETURNS TABLE (
        new_api_key text,
        new_api_key_id uuid)
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
DECLARE
    c_user_id uuid;
    c_scope_id uuid;
    key_description text;
    key_scope_id uuid;
BEGIN
    SELECT
        user_id,
        scope_id INTO c_user_id,
        c_scope_id
    FROM
        keyhippo.current_user_context ();
    IF c_user_id IS NULL THEN
        RAISE EXCEPTION 'Unauthorized: User not authenticated';
    END IF;
    -- Retrieve the description and scope, and ensure the key is not revoked
    SELECT
        ak.description,
        ak.scope_id INTO key_description,
        key_scope_id
    FROM
        keyhippo.api_key_metadata ak
    WHERE
        ak.id = old_api_key_id
        AND ((ak.user_id = c_user_id
                AND ak.scope_id IS NULL)
            OR (ak.scope_id = c_scope_id))
        AND ak.is_revoked = FALSE;
    IF key_description IS NULL THEN
        RAISE EXCEPTION 'Unauthorized: Invalid or inactive API key';
    END IF;
    -- Revoke the old key
    PERFORM
        keyhippo.revoke_api_key (old_api_key_id);
    -- Create a new key with the same description and scope
    RETURN QUERY
    SELECT
        *
    FROM
        keyhippo.create_api_key (key_description, (
                SELECT
                    name
                FROM keyhippo.scopes
                WHERE
                    id = key_scope_id));
END;
$$;

-- RBAC management functions
CREATE OR REPLACE FUNCTION keyhippo_rbac.create_group (p_name text, p_description text)
    RETURNS uuid
    LANGUAGE plpgsql
    SECURITY INVOKER
    AS $$
DECLARE
    v_group_id uuid;
BEGIN
    INSERT INTO keyhippo_rbac.groups (name, description)
        VALUES (p_name, p_description)
    RETURNING
        id INTO v_group_id;
    RETURN v_group_id;
END;
$$;

CREATE OR REPLACE FUNCTION keyhippo_rbac.create_role (p_name text, p_description text, p_group_id uuid, p_role_type keyhippo.app_role)
    RETURNS uuid
    LANGUAGE plpgsql
    SECURITY INVOKER
    AS $$
DECLARE
    v_role_id uuid;
BEGIN
    INSERT INTO keyhippo_rbac.roles (name, description, group_id, role_type)
        VALUES (p_name, p_description, p_group_id, p_role_type)
    RETURNING
        id INTO v_role_id;
    RETURN v_role_id;
END;
$$;

CREATE OR REPLACE FUNCTION keyhippo_rbac.assign_role_to_user (p_user_id uuid, p_group_id uuid, p_role_id uuid)
    RETURNS VOID
    LANGUAGE plpgsql
    SECURITY INVOKER
    AS $$
BEGIN
    INSERT INTO keyhippo_rbac.user_group_roles (user_id, group_id, role_id)
        VALUES (p_user_id, p_group_id, p_role_id)
    ON CONFLICT (user_id, group_id, role_id)
        DO NOTHING;
END;
$$;

CREATE OR REPLACE FUNCTION keyhippo_rbac.assign_permission_to_role (p_role_id uuid, p_permission_name keyhippo.app_permission)
    RETURNS VOID
    LANGUAGE plpgsql
    SECURITY INVOKER
    AS $$
DECLARE
    v_permission_id uuid;
BEGIN
    SELECT
        id INTO v_permission_id
    FROM
        keyhippo_rbac.permissions
    WHERE
        name = p_permission_name;
    IF v_permission_id IS NULL THEN
        RAISE EXCEPTION 'Permission % not found', p_permission_name;
    END IF;
    INSERT INTO keyhippo_rbac.role_permissions (role_id, permission_id)
        VALUES (p_role_id, v_permission_id)
    ON CONFLICT (role_id, permission_id)
        DO NOTHING;
END;
$$;

-- Impersonation functions
CREATE OR REPLACE PROCEDURE keyhippo_impersonation.login_as_user (user_id uuid)
LANGUAGE plpgsql
SECURITY INVOKER
AS $$
DECLARE
    auth_user auth.users%ROWTYPE;
    CURRENT_ROLE NAME;
BEGIN
    -- Ensure only postgres user can call this procedure
    IF CURRENT_USER != 'postgres' THEN
        RAISE EXCEPTION 'Unauthorized';
    END IF;
    -- Get current role before impersonation
    SELECT
        CURRENT_ROLE INTO CURRENT_ROLE;
    -- Fetch the user based on UUID
    SELECT
        * INTO auth_user
    FROM
        auth.users
    WHERE
        id = user_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'User with ID % does not exist', user_id;
    END IF;
    -- Set JWT claims using parameterized queries
    PERFORM
        set_config('request.jwt.claim.sub', auth_user.id::text, TRUE);
    PERFORM
        set_config('request.jwt.claim.role', COALESCE(auth_user.role, 'authenticated'), TRUE);
    IF auth_user.email IS NOT NULL THEN
        PERFORM
            set_config('request.jwt.claim.email', auth_user.email, TRUE);
    END IF;
    IF auth_user.raw_app_meta_data IS NOT NULL THEN
        PERFORM
            set_config('request.jwt.claims', JSON_STRIP_NULLS (JSON_BUILD_OBJECT('app_metadata', auth_user.raw_app_meta_data))::text, TRUE);
    END IF;
    -- Track impersonation state
    INSERT INTO keyhippo_impersonation.impersonation_state (impersonated_user_id, original_role)
        VALUES (user_id, CURRENT_ROLE)
    ON CONFLICT (impersonated_user_id)
        DO UPDATE SET
            original_role = EXCLUDED.original_role, impersonation_time = CURRENT_TIMESTAMP;
    -- Set role
    EXECUTE FORMAT('SET ROLE %I', COALESCE(auth_user.role, 'authenticated'));
    -- Set session timeout
    PERFORM
        set_config('session.impersonation_expires', (NOW() + INTERVAL '1 hour')::text, TRUE);
END;
$$;

CREATE OR REPLACE PROCEDURE keyhippo_impersonation.login_as_anon ()
LANGUAGE plpgsql
SECURITY INVOKER
AS $$
DECLARE
    CURRENT_ROLE NAME;
    ANON_USER_ID uuid := '00000000-0000-0000-0000-000000000000'::uuid;
BEGIN
    -- Ensure only postgres user can call this procedure
    IF CURRENT_USER != 'postgres' THEN
        RAISE EXCEPTION 'Unauthorized';
    END IF;
    -- Get current role before impersonation
    SELECT
        CURRENT_ROLE INTO CURRENT_ROLE;
    -- Set JWT claims for anonymous login
    PERFORM
        set_config('request.jwt.claim.sub', 'anon', TRUE);
    PERFORM
        set_config('request.jwt.claim.role', 'anon', TRUE);
    PERFORM
        set_config('request.jwt.claim.email', '', TRUE);
    PERFORM
        set_config('request.jwt.claims', json_build_object('sub', 'anon', 'role', 'anon')::text, TRUE);
    -- Track impersonation state
    DELETE FROM keyhippo_impersonation.impersonation_state
    WHERE impersonated_user_id = ANON_USER_ID;
    INSERT INTO keyhippo_impersonation.impersonation_state (impersonated_user_id, original_role)
        VALUES (ANON_USER_ID, CURRENT_ROLE);
    -- Set role to anon
    SET ROLE anon;
    -- Set session timeout
    PERFORM
        set_config('session.impersonation_expires', (NOW() + INTERVAL '1 hour')::text, TRUE);
    RAISE NOTICE 'Anonymous login successful. Impersonated user ID: %, Original role: %, Session expires: %', ANON_USER_ID, CURRENT_ROLE, current_setting('session.impersonation_expires', TRUE);
END;
$$;

CREATE OR REPLACE PROCEDURE keyhippo_impersonation.logout ()
LANGUAGE plpgsql
AS $$
DECLARE
    v_original_role text;
BEGIN
    IF current_setting('session.impersonation_expires', TRUE) IS NULL THEN
        RAISE EXCEPTION 'Not in an impersonation session';
    END IF;
    SELECT
        original_role::text INTO v_original_role
    FROM
        keyhippo_impersonation.impersonation_state
    WHERE
        impersonated_user_id = '00000000-0000-0000-0000-000000000000'::uuid;
    IF v_original_role IS NULL THEN
        RAISE EXCEPTION 'Current user is not being impersonated';
    END IF;
    PERFORM
        set_config('request.jwt.claim.sub', '', TRUE);
    PERFORM
        set_config('request.jwt.claim.role', '', TRUE);
    PERFORM
        set_config('request.jwt.claim.email', '', TRUE);
    PERFORM
        set_config('request.jwt.claims', '', TRUE);
    EXECUTE FORMAT('SET ROLE %I', v_original_role);
    DELETE FROM keyhippo_impersonation.impersonation_state
    WHERE impersonated_user_id = '00000000-0000-0000-0000-000000000000'::uuid;
    PERFORM
        set_config('session.impersonation_expires', '', TRUE);
    RAISE NOTICE 'Logout successful. Original role: %', v_original_role;
END;
$$;

-- RLS Policies
ALTER TABLE keyhippo_internal.config ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo_rbac.groups ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo_rbac.roles ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo_rbac.permissions ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo_rbac.role_permissions ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo_rbac.user_group_roles ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo.scopes ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo.scope_permissions ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo.api_key_metadata ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo.api_key_secrets ENABLE ROW LEVEL SECURITY;

ALTER TABLE keyhippo_impersonation.impersonation_state ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY config_access_policy ON keyhippo_internal.config
    USING (CURRENT_USER = 'postgres');

CREATE POLICY groups_access_policy ON keyhippo_rbac.groups
    FOR ALL TO authenticated
        USING (keyhippo.authorize ('manage_groups'))
        WITH CHECK (keyhippo.authorize ('manage_groups'));

CREATE POLICY roles_access_policy ON keyhippo_rbac.roles
    FOR ALL TO authenticated
        USING (keyhippo.authorize ('manage_roles'))
        WITH CHECK (keyhippo.authorize ('manage_roles'));

CREATE POLICY permissions_access_policy ON keyhippo_rbac.permissions
    FOR ALL TO authenticated
        USING (keyhippo.authorize ('manage_permissions'))
        WITH CHECK (keyhippo.authorize ('manage_permissions'));

CREATE POLICY role_permissions_access_policy ON keyhippo_rbac.role_permissions
    FOR ALL TO authenticated
        USING (keyhippo.authorize ('manage_roles'))
        WITH CHECK (keyhippo.authorize ('manage_roles'));

CREATE POLICY user_group_roles_access_policy ON keyhippo_rbac.user_group_roles
    FOR ALL TO authenticated
        USING (keyhippo.authorize ('manage_roles'))
        WITH CHECK (keyhippo.authorize ('manage_roles'));

CREATE POLICY scopes_access_policy ON keyhippo.scopes
    FOR ALL TO authenticated
        USING (keyhippo.authorize ('manage_scopes'))
        WITH CHECK (keyhippo.authorize ('manage_scopes'));

CREATE POLICY scope_permissions_access_policy ON keyhippo.scope_permissions
    FOR ALL TO authenticated
        USING (keyhippo.authorize ('manage_scopes'))
        WITH CHECK (keyhippo.authorize ('manage_scopes'));

CREATE POLICY api_key_metadata_access_policy ON keyhippo.api_key_metadata
    FOR ALL TO authenticated
        USING (user_id = auth.uid ()
            OR keyhippo.authorize ('manage_api_keys'));

CREATE POLICY api_key_secrets_no_access_policy ON keyhippo.api_key_secrets
    FOR ALL TO authenticated
        USING (FALSE);

CREATE POLICY impersonation_state_access ON keyhippo_impersonation.impersonation_state
    USING (CURRENT_USER = 'postgres'
        OR (CURRENT_USER = 'anon' AND impersonated_user_id = '00000000-0000-0000-0000-000000000000'::uuid)
        OR impersonated_user_id::text = CURRENT_USER);

-- Grants and Permissions
GRANT USAGE ON SCHEMA keyhippo TO authenticated, anon;

GRANT USAGE ON SCHEMA keyhippo_internal TO postgres;

GRANT ALL PRIVILEGES ON keyhippo_internal.config TO postgres;

GRANT USAGE ON SCHEMA keyhippo_rbac TO authenticated, anon;

-- Grant EXECUTE on functions
GRANT EXECUTE ON FUNCTION keyhippo.create_api_key (text, text) TO authenticated;

GRANT EXECUTE ON FUNCTION keyhippo.verify_api_key (text) TO authenticated;

GRANT EXECUTE ON FUNCTION keyhippo.current_user_context () TO authenticated;

GRANT EXECUTE ON FUNCTION keyhippo.revoke_api_key (uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION keyhippo.rotate_api_key (uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION keyhippo.authorize (keyhippo.app_permission) TO authenticated, anon;

GRANT EXECUTE ON FUNCTION keyhippo_rbac.create_group (text, text) TO authenticated;

GRANT EXECUTE ON FUNCTION keyhippo_rbac.create_role (text, text, uuid, keyhippo.app_role) TO authenticated;

GRANT EXECUTE ON FUNCTION keyhippo_rbac.assign_role_to_user (uuid, uuid, uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION keyhippo_rbac.assign_permission_to_role (uuid, keyhippo.app_permission) TO authenticated;

-- Grant SELECT, INSERT, UPDATE, DELETE on tables
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA keyhippo TO authenticated;

GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA keyhippo_rbac TO authenticated;

-- Revoke all permissions on api_key_secrets from authenticated users
REVOKE ALL ON TABLE keyhippo.api_key_secrets FROM authenticated;

-- Grant necessary permissions to service_role
GRANT ALL ON ALL TABLES IN SCHEMA keyhippo TO service_role;

GRANT ALL ON ALL TABLES IN SCHEMA keyhippo_rbac TO service_role;

-- Grant necessary permissions for impersonation
GRANT USAGE ON SCHEMA keyhippo_impersonation TO postgres, authenticated, anon;

GRANT ALL ON TABLE keyhippo_impersonation.impersonation_state TO postgres;

GRANT EXECUTE ON PROCEDURE keyhippo_impersonation.login_as_user (UUID) TO postgres;

GRANT EXECUTE ON PROCEDURE keyhippo_impersonation.login_as_anon () TO postgres;

GRANT EXECUTE ON PROCEDURE keyhippo_impersonation.logout () TO authenticated, anon;

GRANT SELECT, DELETE ON keyhippo_impersonation.impersonation_state TO anon;

-- Function to send initial installation notification
CREATE OR REPLACE FUNCTION keyhippo_internal.send_installation_notification ()
    RETURNS VOID
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
DECLARE
    v_installation_uuid uuid;
    v_endpoint text;
    v_payload jsonb;
    v_should_send boolean;
BEGIN
    -- Get installation UUID and endpoint from config
    SELECT
        value::uuid INTO v_installation_uuid
    FROM
        keyhippo_internal.config
    WHERE
        key = 'installation_uuid';
    SELECT
        value INTO v_endpoint
    FROM
        keyhippo_internal.config
    WHERE
        key = 'audit_log_endpoint';
    -- Check if we should send the notification
    SELECT
        value::boolean INTO v_should_send
    FROM
        keyhippo_internal.config
    WHERE
        key = 'send_installation_notification';
    IF v_should_send THEN
        -- Prepare the payload
        v_payload := jsonb_build_object('event', 'installation', 'installation_uuid', v_installation_uuid, 'timestamp', now());
        -- Send the notification
        PERFORM
            net.http_post (url := v_endpoint, body := v_payload, headers := jsonb_build_object('Content-Type', 'application/json'));
        -- Update the config to prevent future notifications
        UPDATE
            keyhippo_internal.config
        SET
            value = 'false'
        WHERE
            key = 'send_installation_notification';
    END IF;
END;
$$;

-- Initialization function
CREATE OR REPLACE FUNCTION keyhippo.initialize_keyhippo ()
    RETURNS VOID
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
DECLARE
    admin_group_id uuid;
    admin_role_id uuid;
    installation_uuid uuid;
    user_group_id uuid;
    user_role_id uuid;
BEGIN
    -- Upsert the default value for the audit log endpoint
    INSERT INTO keyhippo_internal.config (key, value, description)
        VALUES ('audit_log_endpoint', 'https://app.keyhippo.com/api/echo', 'Endpoint for sending audit log notifications')
    ON CONFLICT (key)
        DO UPDATE SET
            value = EXCLUDED.value, description = EXCLUDED.description;
    -- Generate and store installation UUID
    installation_uuid := gen_random_uuid ();
    INSERT INTO keyhippo_internal.config (key, value, description)
        VALUES ('installation_uuid', installation_uuid::text, 'Unique identifier for this KeyHippo installation')
    ON CONFLICT (key)
        DO UPDATE SET
            value = EXCLUDED.value, description = EXCLUDED.description;
    -- Set HTTP logging to false by default
    INSERT INTO keyhippo_internal.config (key, value, description)
        VALUES ('enable_http_logging', 'false', 'Flag to enable/disable HTTP logging')
    ON CONFLICT (key)
        DO UPDATE SET
            value = EXCLUDED.value, description = EXCLUDED.description;
    -- Create default groups
    INSERT INTO keyhippo_rbac.groups (name, description)
        VALUES ('Admin Group', 'Group for administrators'),
        ('User Group', 'Group for regular users')
    ON CONFLICT (name)
        DO NOTHING;
    -- Fetch group IDs
    SELECT
        id INTO admin_group_id
    FROM
        keyhippo_rbac.groups
    WHERE
        name = 'Admin Group';
    SELECT
        id INTO user_group_id
    FROM
        keyhippo_rbac.groups
    WHERE
        name = 'User Group';
    -- Create default roles
    INSERT INTO keyhippo_rbac.roles (name, description, group_id, role_type)
        VALUES ('Admin', 'Administrator role', admin_group_id, 'admin'),
        ('User', 'Regular user role', user_group_id, 'user')
    ON CONFLICT (name, group_id)
        DO NOTHING;
    -- Fetch role IDs
    SELECT
        id INTO admin_role_id
    FROM
        keyhippo_rbac.roles
    WHERE
        name = 'Admin'
        AND group_id = admin_group_id;
    SELECT
        id INTO user_role_id
    FROM
        keyhippo_rbac.roles
    WHERE
        name = 'User'
        AND group_id = user_group_id;
    -- Create default permissions
    INSERT INTO keyhippo_rbac.permissions (name, description)
        VALUES ('manage_groups', 'Manage groups'),
        ('manage_roles', 'Manage roles'),
        ('manage_permissions', 'Manage permissions'),
        ('manage_scopes', 'Manage scopes'),
        ('manage_api_keys', 'Manage API keys'),
        ('manage_user_attributes', 'Manage user attributes')
    ON CONFLICT (name)
        DO NOTHING;
    -- Assign all permissions to the Admin role
    INSERT INTO keyhippo_rbac.role_permissions (role_id, permission_id)
    SELECT
        admin_role_id,
        id
    FROM
        keyhippo_rbac.permissions
    ON CONFLICT (role_id,
        permission_id)
        DO NOTHING;
    -- Assign manage_api_keys permission to the User role
    INSERT INTO keyhippo_rbac.role_permissions (role_id, permission_id)
    SELECT
        user_role_id,
        id
    FROM
        keyhippo_rbac.permissions
    WHERE
        name = 'manage_api_keys'
    ON CONFLICT (role_id,
        permission_id)
        DO NOTHING;
    -- Create a default scope
    INSERT INTO keyhippo.scopes (name, description)
        VALUES ('default', 'Default scope for API keys')
    ON CONFLICT (name)
        DO NOTHING;
    -- Set up the send_installation_notification config if it doesn't exist
    INSERT INTO keyhippo_internal.config (key, value, description)
        VALUES ('send_installation_notification', 'true', 'Flag to send initial installation notification')
    ON CONFLICT (key)
        DO NOTHING;
    -- This ensures we don't overwrite an existing value
    -- Send the installation notification only if the config is set to true
    IF (
        SELECT
            value::boolean
        FROM
            keyhippo_internal.config
        WHERE
            key = 'send_installation_notification') THEN
        PERFORM
            keyhippo_internal.send_installation_notification ();
    END IF;
END;
$$;

-- Function to assign the default user role to a new user
CREATE OR REPLACE FUNCTION keyhippo.assign_default_role ()
    RETURNS TRIGGER
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
DECLARE
    user_group_id uuid;
    user_role_id uuid;
BEGIN
    SELECT
        id INTO user_group_id
    FROM
        keyhippo_rbac.groups
    WHERE
        name = 'User Group';
    SELECT
        id INTO user_role_id
    FROM
        keyhippo_rbac.roles
    WHERE
        name = 'User'
        AND group_id = user_group_id;
    INSERT INTO keyhippo_rbac.user_group_roles (user_id, group_id, role_id)
        VALUES (NEW.id, user_group_id, user_role_id)
    ON CONFLICT (user_id, group_id, role_id)
        DO NOTHING;
    RETURN NEW;
END;
$$;

-- Create a trigger to assign the default role to new users
CREATE TRIGGER keyhippo_assign_default_role_trigger
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION keyhippo.assign_default_role ();

-- Function to initialize KeyHippo for an existing Supabase project
CREATE OR REPLACE FUNCTION keyhippo.initialize_existing_project ()
    RETURNS VOID
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
DECLARE
    user_record RECORD;
    user_group_id uuid;
    user_role_id uuid;
BEGIN
    -- Initialize KeyHippo
    PERFORM
        keyhippo.initialize_keyhippo ();
    -- Get the User Group and Role IDs
    SELECT
        id INTO user_group_id
    FROM
        keyhippo_rbac.groups
    WHERE
        name = 'User Group';
    SELECT
        id INTO user_role_id
    FROM
        keyhippo_rbac.roles
    WHERE
        name = 'User'
        AND group_id = user_group_id;
    -- Assign the default role to all existing users
    FOR user_record IN
    SELECT
        id
    FROM
        auth.users LOOP
            INSERT INTO keyhippo_rbac.user_group_roles (user_id, group_id, role_id)
                VALUES (user_record.id, user_group_id, user_role_id)
            ON CONFLICT (user_id, group_id, role_id)
                DO NOTHING;
        END LOOP;
END;
$$;

-- Run the initialization function
SELECT
    keyhippo.initialize_keyhippo ();

-- Notify PostgREST to reload configuration
NOTIFY pgrst,
'reload config';
